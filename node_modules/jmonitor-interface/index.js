"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
//require rest for Grabber Class;
var Client = require('node-rest-client').Client;
var Grabber = (function () {
    function Grabber(JmonitorOption) {
        this.JmonitorOption = JmonitorOption;
        this.doGet = function (options, cb) {
            var client = new Client();
            var req = client.get("http://remote.site/rest/xml/method", function (data, response) {
                // parsed response body as js object 
                console.log(data);
                // raw response 
                console.log(response);
            });
            req.on('requestTimeout', function (req) {
                console.log('request has expired');
                req.abort();
            });
            req.on('responseTimeout', function (res) {
                console.log('response has expired');
            });
            //it's usefull to handle request errors to avoid, for example, socket hang up errors on request timeouts 
            req.on('error', function (err) {
                console.log('request error', err);
            });
        };
        this.doPut = function (options, data, callback) {
            var client = new Client();
            var args = {
                path: { "id": 120 },
                parameters: { arg1: "hello", arg2: "world" },
                headers: options.header,
                data: data
            };
            var req = client.put(options.host + options.path, args, function (data, response) {
                // parsed response body as js object 
                console.log(data);
                // raw response 
                console.log(response);
            });
            req.on('requestTimeout', function (req) {
                console.log('request has expired');
                req.abort();
            });
            req.on('responseTimeout', function (res) {
                console.log('response has expired');
            });
            //it's usefull to handle request errors to avoid, for example, socket hang up errors on request timeouts 
            req.on('error', function (err) {
                console.log('request error', err);
            });
        };
    }
    ;
    return Grabber;
}());
exports.Grabber = Grabber;
var Bookmaker = (function () {
    function Bookmaker(id, name) {
        this.id = id;
        this.name = name;
    }
    return Bookmaker;
}());
exports.Bookmaker = Bookmaker;
var Sign = (function () {
    function Sign(name) {
        var _this = this;
        this.changed = false;
        this.setPrice = function (x) {
            if (_this.oldPrice != _this.price)
                _this.changed = true;
            else
                _this.changed = false;
            _this.oldPrice = _this.price;
            _this.price = x;
            return _this.changed;
        };
        this.getPrice = function () { return _this.price; };
        this.name = name;
    }
    return Sign;
}());
exports.Sign = Sign;
var Market = (function () {
    function Market(name) {
        this.name = name;
    }
    return Market;
}());
exports.Market = Market;
var Market1X2 = (function (_super) {
    __extends(Market1X2, _super);
    function Market1X2() {
        var _this = _super.call(this, '1X2') || this;
        _this.update = function (signs) {
            var changed = false;
            for (var index in signs) {
                if (_this.signs[index].name == signs[index].name)
                    changed = changed || _this.signs[index].setPrice(signs[index].getPrice());
                else
                    throw ("Position of signs in the input array must be in the following format [1,X,2] ");
            }
            return changed;
        };
        _this.signs = [new Sign("1"), new Sign("X"), new Sign("2")];
        return _this;
    }
    return Market1X2;
}(Market));
exports.Market1X2 = Market1X2;
var Competitior = (function () {
    function Competitior(bookmakerId, name) {
        this.bookmakerId = bookmakerId;
        this.name = name;
        this.market1X2 = new Market1X2();
    }
    return Competitior;
}());
exports.Competitior = Competitior;
var Fixture = (function () {
    function Fixture(book, betradarId, name, bookmakers, date, league, leagueId) {
        this.competitiors = [];
        if (typeof league !== "undefined")
            this.league = league;
        if (typeof leagueId !== "undefined")
            this.leagueId = leagueId;
        this.betradarId = betradarId;
        this.name = name;
        this.date = date;
        for (var _i = 0, bookmakers_1 = bookmakers; _i < bookmakers_1.length; _i++) {
            var b = bookmakers_1[_i];
            this.competitiors.push(new Competitior(b.id, b.name));
        }
    }
    Fixture.prototype.getCompetitor = function (book) {
        var r;
        for (var _i = 0, _a = this.competitiors; _i < _a.length; _i++) {
            var c = _a[_i];
            if (c.bookmakerId == book.id) {
                r = c;
                break;
            }
        }
        return r;
    };
    return Fixture;
}());
exports.Fixture = Fixture;
var Fixtures = (function () {
    function Fixtures() {
        this.map = {};
        this.map = {};
    }
    Fixtures.getInstance = function () {
        if (!Fixtures.instance) {
            Fixtures.instance = new Fixtures();
        }
        return Fixtures.instance;
    };
    Fixtures.prototype.merge = function (fixture, book) {
        if (this.map[fixture.betradarId]) {
            //get competitor of book;
            var input = fixture.getCompetitor(book).market1X2.signs;
            //update the competitior
            if (this.map[fixture.betradarId].getCompetitor(book).market1X2.update(input))
                return input;
            else
                return Object.keys(this.map).length;
        }
        else {
            //insert new fixture
            this.map[fixture.betradarId] = fixture;
            return Object.keys(this.map).length;
        }
    };
    return Fixtures;
}());
exports.Fixtures = Fixtures;
